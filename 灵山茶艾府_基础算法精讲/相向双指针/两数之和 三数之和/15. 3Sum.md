---

---
**做题时间**：2026-1-9
**难度**： Medium

## 题目截图
---
![](assets/15.%203Sum/file-20260109163627028.png)
## 回答
---
```python

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        l,r =1, len(nums)-1
        numss = sorted(nums)
        n = 0
        output = []
        
        for i in range(r -1):
            l,r = i+1, len(nums)-1
            while l < r:
                if numss[i] + numss[l] + numss[r] ==0:
                    output.insert(n, [numss[i],numss[l],numss[r]])
                    n += 1
                    l += 1
                elif numss[i] + numss[l] + numss[r] >0:
                    l += 1
                else:
                    r -= 1
            continue
        return output
```
**总结**：
1. 错误的原因：
	1. if语句中r -=1 和 l +=1 写反了
	2. 没有判断重复解
2. 可以优化的地方：
	1. 可以直接用output.append 没必要使用insert
	2. 在找到解之后可以直接执行r -=1 和 l +=1，代码中只执行了l += 1
	3. 变量重命名可以更加规范

## 参考答案
---
灵山茶艾府
```python

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort() ##直接排序
        ans =[] ## 建立一个新的数组
        n = len(nums) 

        for i in range(n-2):
            x = nums[i]
            if i > 0 and x == nums[i-1]: ## 防止重复解，从第二个元素开始判断因此 i > 0
                continue
            l,r = i+1, n-1
            while l < r: ## 还是运用双指针夹解的方式
                s = x + nums[l] + nums[r]
                if s > 0:
                    r -= 1
                elif s < 0:
                    l += 1
                else:
                    ans.append([x,nums[l],nums[r]])
                    l += 1
                    while l < r and nums[l] == nums[l-1]:## 防止重复解
                        l += 1
                    r -= 1
                    while l < r and nums[r] == nums[r+1]:
                        r -= 1
        return ans
```
**考点**：
1. 相向双指针的妙用
2. 注意过滤重复解
3. 在写代码的过程中不要乱